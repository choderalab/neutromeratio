import numpy as np
from .config import speed_unit, distance_unit, kB
from simtk import unit
from tqdm import tqdm
from .utils import write_xyz_file
from .mcmc import MC_mover
from .ani import ANI1cxx_force_and_energy
import mdtraj as md
import torchani
import torch
import os

class LangevinDynamics(object):

    def __init__(self, atom_list:str, device:torch.device, model:torchani.models.ANI1ccx, temperature:int, force:ANI1cxx_force_and_energy):
        self.device = device
        self.model = model
        self.force = force
        self.temperature = temperature
        self.atom_list = atom_list


    def run_dynamics(self, x0:np.ndarray, 
                    n_steps:int=100,
                    stepsize:int=1 * unit.femtosecond,
                    collision_rate:int=10/unit.picoseconds,
                     progress_bar:bool=False
            ):
        """Unadjusted Langevin dynamics.

        Parameters
        ----------
        x0 : array of floats, unit'd (distance unit)
            initial configuration
        force : callable, accepts a unit'd array and returns a unit'd array
            assumes input is in units of distance
            output is in units of energy / distance
        n_steps : integer
            number of Langevin steps
        stepsize : float > 0, in units of time
            finite timestep parameter
        collision_rate : float > 0, in units of 1/time
            controls the rate of interaction with the heat bath
        progress_bar : bool
            use tqdm to show progress bar

        Returns
        -------
        traj : [n_steps + 1 x dim] array of floats, unit'd
            trajectory of samples generated by Langevin dynamics

        """

        assert(type(x0) == unit.Quantity)
        assert(type(stepsize) == unit.Quantity)
        assert(type(collision_rate) == unit.Quantity)
        assert(type(self.temperature) == unit.Quantity)

        # generate mass arrays
        mass_dict_in_daltons = {'H': 1.0, 'C': 12.0, 'N': 14.0, 'O': 16.0}
        masses = np.array([mass_dict_in_daltons[a] for a in self.atom_list]) * unit.daltons
        sigma_v = np.array([unit.sqrt(kB * self.temperature / m) / speed_unit for m in masses]) * speed_unit
        v0 = np.random.randn(len(sigma_v),3) * sigma_v[:,None]
        # convert initial state numpy arrays with correct attached units
        x = np.array(x0.value_in_unit(distance_unit)) * distance_unit
        v = np.array(v0.value_in_unit(speed_unit)) * speed_unit

        # traj is accumulated as a list of arrays with attached units
        traj = [x]
        # dimensionless scalars
        a = np.exp(- collision_rate * stepsize)
        b = np.sqrt(1 - np.exp(-2 * collision_rate * stepsize))

        # compute force on initial configuration
        F = self.force.calculate_force(x)
        trange = range(n_steps)
        if progress_bar:
            trange = tqdm(trange)
        for _ in trange:

            # v
            v += (stepsize * 0.5) * F / masses[:,None]
            # r
            x += (stepsize * 0.5) * v
            # o
            v = (a * v) + (b * sigma_v[:,None] * np.random.randn(*x.shape))
            # r
            x += (stepsize * 0.5) * v
            F = self.force.calculate_force(x)
            # v
            v += (stepsize * 0.5) * F / masses[:,None]

            norm_F = np.linalg.norm(F)
            # report gradient norm
            if progress_bar:
                trange.set_postfix({'|force|': norm_F})
            # check positions and forces are finite
            if (not np.isfinite(x).all()) or (not np.isfinite(norm_F)):
                print("Numerical instability encountered!")
                return traj
            traj.append(x)
        return traj, x


def performe_md_mc_protocoll(name:str, 
                            run:int,
                            x0,
                            nr_of_mc_trials:int, 
                            hydrogen_mover:MC_mover,
                            langevin_dynamics:LangevinDynamics,
                            from_mol_tautomer_idx:int, 
                            to_mol_tautomer_idx:int):

    if not os.path.exists(f"../data/structures/{name}/"):
        os.mkdir(f"../data/structures/{name}/")

    # generating mdtraj traj object
    topology = md.load(f"../data/structures/{name}/{name}_tautomer_{from_mol_tautomer_idx}.pdb").topology

    print(f"Run Nr: {run}")
    trange = tqdm(range(nr_of_mc_trials))

    traj_in_nm = []
    work_value = []
    
    for mc_moves in trange:

        trajectory, final_coordinate_set = langevin_dynamics.run_dynamics(x0)
        traj_in_nm += [x / unit.nanometer for x in trajectory]
        
        # for debug purpose: write out mol before MC move
        write_xyz_file(hydrogen_mover.atom_list, final_coordinate_set, name=f"{name}_t{from_mol_tautomer_idx}", identifier=f"{run}_{mc_moves}_0_pre_jump")
        # MC move
        new_coordinates, work = hydrogen_mover.perform_mc_move(final_coordinate_set)
        work_value.append(work)
        # for debug purpose: write out mol after MC move
        write_xyz_file(hydrogen_mover.atom_list, new_coordinates, name=f"{name}_t{from_mol_tautomer_idx}", identifier=f"{run}_{mc_moves}_1_post_jump")
        # update new coordinates for langevin dynamics
        x0 = final_coordinate_set
        
        
    ani_traj = md.Trajectory(traj_in_nm, topology)
    ani_traj.save(f"../data/md_mc_sampling/{name}/{name}_t{from_mol_tautomer_idx}_run{run}_anicxx.dcd")

    f = open(f"../data/md_mc_sampling/{name}/{name}_from_t{from_mol_tautomer_idx}_to_t{to_mol_tautomer_idx}_run{run}_work.csv", 'w+')
    for i, j in zip(range(nr_of_mc_trials), work_value):
        f.write('{}, {}\n'.format(i, j))
    f.close()



def use_precalculated_md_and_performe_mc(name:str, 
                            run:int,
                            hydrogen_mover:MC_mover,
                            from_mol_tautomer_idx:int, 
                            to_mol_tautomer_idx:int):

    pass