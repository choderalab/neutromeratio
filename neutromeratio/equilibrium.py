import numpy as np
from .config import speed_unit, distance_unit, kB
from simtk import unit
from tqdm import tqdm


def langevin(device,
             model,
             atom_list:str,
             x0:np.ndarray,
             force,
             n_steps:int=100,
             stepsize:int=1 * unit.femtosecond,
             collision_rate:int=10/unit.picoseconds,
             temperature:int=300 * unit.kelvin,
             platform:str = 'cpu',
             progress_bar:bool=False
            ):
    """Unadjusted Langevin dynamics.

    Parameters
    ----------
    device,
    model,
    atom_list
    x0 : array of floats, unit'd (distance unit)
        initial configuration
    force : callable, accepts a unit'd array and returns a unit'd array
        assumes input is in units of distance
        output is in units of energy / distance
    n_steps : integer
        number of Langevin steps
    stepsize : float > 0, in units of time
        finite timestep parameter
    collision_rate : float > 0, in units of 1/time
        controls the rate of interaction with the heat bath
    temperature : float > 0, in units of temperature
    progress_bar : bool
        use tqdm to show progress bar

    Returns
    -------
    traj : [n_steps + 1 x dim] array of floats, unit'd
        trajectory of samples generated by Langevin dynamics

    """

    assert(type(x0) == unit.Quantity)
    assert(type(stepsize) == unit.Quantity)
    assert(type(collision_rate) == unit.Quantity)
    assert(type(temperature) == unit.Quantity)

    # generate mass arrays
    mass_dict_in_daltons = {'H': 1.0, 'C': 12.0, 'N': 14.0, 'O': 16.0}
    masses = np.array([mass_dict_in_daltons[a] for a in atom_list]) * unit.daltons
    sigma_v = np.array([unit.sqrt(kB * temperature / m) / speed_unit for m in masses]) * speed_unit
    v0 = np.random.randn(len(sigma_v),3) * sigma_v[:,None]
    # convert initial state numpy arrays with correct attached units
    x = np.array(x0.value_in_unit(distance_unit)) * distance_unit
    v = np.array(v0.value_in_unit(speed_unit)) * speed_unit

    # traj is accumulated as a list of arrays with attached units
    traj = [x]
    # dimensionless scalars
    a = np.exp(- collision_rate * stepsize)
    b = np.sqrt(1 - np.exp(-2 * collision_rate * stepsize))

    species = model.species_to_tensor(atom_list).to(device).unsqueeze(0)
    # compute force on initial configuration
    F = force(x, device, model, species, platform)
    trange = range(n_steps)
    if progress_bar:
        trange = tqdm(trange)
    for _ in trange:

        # v
        v += (stepsize * 0.5) * F / masses[:,None]
        # r
        x += (stepsize * 0.5) * v
        # o
        v = (a * v) + (b * sigma_v[:,None] * np.random.randn(*x.shape))
        # r
        x += (stepsize * 0.5) * v
        F = force(x, device, model, species, platform)
        # v
        v += (stepsize * 0.5) * F / masses[:,None]

        norm_F = np.linalg.norm(F)
        # report gradient norm
        if progress_bar:
            trange.set_postfix({'|force|': norm_F})
        # check positions and forces are finite
        if (not np.isfinite(x).all()) or (not np.isfinite(norm_F)):
            print("Numerical instability encountered!")
            return traj
        traj.append(x)
    return traj, x
