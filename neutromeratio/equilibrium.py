import numpy as np
from .config import speed_unit, distance_unit, kB
from simtk import unit
from tqdm import tqdm
from .utils import write_xyz_file
from .mcmc import MC_mover
from .ani import ANI1cxx_force_and_energy
import mdtraj as md
import torchani
import torch
import os

class LangevinDynamics(object):

    def __init__(self, atom_list:str, temperature:int, force:ANI1cxx_force_and_energy):
        self.force = force
        self.temperature = temperature
        self.atom_list = atom_list


    def run_dynamics(self, x0:np.ndarray, 
                    n_steps:int=100,
                    stepsize:unit.Quantity=1 * unit.femtosecond,
                    collision_rate:unit.Quantity=10/unit.picoseconds,
                     progress_bar:bool=False
            ):
        """Unadjusted Langevin dynamics.

        Parameters
        ----------
        x0 : array of floats, unit'd (distance unit)
            initial configuration
        force : callable, accepts a unit'd array and returns a unit'd array
            assumes input is in units of distance
            output is in units of energy / distance
        n_steps : integer
            number of Langevin steps
        stepsize : float > 0, in units of time
            finite timestep parameter
        collision_rate : float > 0, in units of 1/time
            controls the rate of interaction with the heat bath
        progress_bar : bool
            use tqdm to show progress bar

        Returns
        -------
        traj : [n_steps + 1 x dim] array of floats, unit'd
            trajectory of samples generated by Langevin dynamics

        """

        assert(type(x0) == unit.Quantity)
        assert(type(stepsize) == unit.Quantity)
        assert(type(collision_rate) == unit.Quantity)
        assert(type(self.temperature) == unit.Quantity)

        # generate mass arrays
        mass_dict_in_daltons = {'H': 1.0, 'C': 12.0, 'N': 14.0, 'O': 16.0}
        masses = np.array([mass_dict_in_daltons[a] for a in self.atom_list]) * unit.daltons
        sigma_v = np.array([unit.sqrt(kB * self.temperature / m) / speed_unit for m in masses]) * speed_unit
        v0 = np.random.randn(len(sigma_v),3) * sigma_v[:,None]
        # convert initial state numpy arrays with correct attached units
        x = np.array(x0.value_in_unit(distance_unit)) * distance_unit
        v = np.array(v0.value_in_unit(speed_unit)) * speed_unit

        # traj is accumulated as a list of arrays with attached units
        traj = [x]
        # dimensionless scalars
        a = np.exp(- collision_rate * stepsize)
        b = np.sqrt(1 - np.exp(-2 * collision_rate * stepsize))

        # compute force on initial configuration
        F = self.force.calculate_force(x)
        trange = range(n_steps)
        if progress_bar:
            trange = tqdm(trange)
        for _ in trange:

            # v
            v += (stepsize * 0.5) * F / masses[:,None]
            # r
            x += (stepsize * 0.5) * v
            # o
            v = (a * v) + (b * sigma_v[:,None] * np.random.randn(*x.shape))
            # r
            x += (stepsize * 0.5) * v
            F = self.force.calculate_force(x)
            # v
            v += (stepsize * 0.5) * F / masses[:,None]

            norm_F = np.linalg.norm(F)
            # report gradient norm
            if progress_bar:
                trange.set_postfix({'|force|': norm_F})
            # check positions and forces are finite
            if (not np.isfinite(x).all()) or (not np.isfinite(norm_F)):
                print("Numerical instability encountered!")
                return traj
            traj.append(x)
        return traj, x


def performe_md_mc_protocoll(x0:unit.Quantity,
                            nr_of_mc_trials:int, 
                            hydrogen_mover:MC_mover,
                            langevin_dynamics:LangevinDynamics):
    

    trange = tqdm(range(nr_of_mc_trials))
    traj_in_nm = []
    
    for _ in trange:

        trajectory, final_coordinate_set = langevin_dynamics.run_dynamics(x0)
        traj_in_nm += [x / unit.nanometer for x in trajectory]      
        # MC move
        new_coordinates, work = hydrogen_mover.perform_mc_move(final_coordinate_set)
        hydrogen_mover.list_of_proposed_coordinates.append(new_coordinates)
        hydrogen_mover.list_of_initial_coordinates.append(final_coordinate_set)
        hydrogen_mover.work_values.append(work)
        # update new coordinates for langevin dynamics
        x0 = final_coordinate_set

    return traj_in_nm
        
        

def use_precalculated_md_and_performe_mc(top:str,
                                        trajs:list,
                                        hydrogen_movers:list):

    """
    Iterates over a trajectory and performs MC moves.
    The hydrogen_movers specify a list of MC_mover objects that should be used on the same coordinate set. 
    """
    topology = md.load(top).topology
    traj = md.load(trajs, top=topology)
    for x in traj:
        coordinates = x.xyz[0] * unit.nanometer
        for hydrogen_mover in hydrogen_movers:
            # MC move
            new_coordinates, work = hydrogen_mover.perform_mc_move(coordinates)
            hydrogen_mover.list_of_proposed_coordinates.append(new_coordinates)
            hydrogen_mover.list_of_initial_coordinates.append(final_coordinate_set)
            hydrogen_mover.work_values.append(work)
            
